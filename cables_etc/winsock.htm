<html>
<head>
<!-- This document was created from RTF source by rtftohtml version 2.7.4 -->
<title>Windows Sockets</title>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080">

<h1><IMG ALIGN=BOTTOM SRC="winsock.gif"> Windows Sockets</h1>

<h2>An Open Interface for<br>
Network Programming under<br>
Microsoft Windows<br></h2>

<h3>Version 1.1<br>
20 January 1993</h3>

<hr>

<h2>Note</h2>

This HTML version of the Windows Socket 1.1 Specification is provided
by Mark Towfiq.  It may be freely redistributed, either as provided or
in modified form.  Winsock providers may integrate it into their
product documentation without incurring any obligation.

<h2>Acknowledgements</h2>

I am indebted and thankful to:
<ul>

<li> <A HREF="mailto:joel@infomagic.com">Joel Golberger</A> of
InfoMagic, Inc. for the work he did on the <A HREF="winsock.hlp">
Windows Help version</A> of the <A HREF="winsock.rtf">Windows Sockets
Specification</A>.  I used <A HREF="winsockx.rtf">his .RTF file</A> as
the source file for this document.

<li> <A HREF="mailto:cjh@cray.com">Chris Hector</A> of
Cray Research Inc. for his package
<a href="ftp://ftp.cray.com/src/WWWstuff/RTF/rtftohtml_overview.html">rtftohtml</a>, which was used to generate this document.

</ul>

<ADDRESS>
<A HREF="http://SunSite.UNC.Edu/towfiq">Mark Towfiq</A>
<EM> (<A HREF="mailto:towfiq@East.Sun.Com">towfiq@East.Sun.Com</A>) </EM>
</ADDRESS>

<hr>
<H1>Table of Contents</H1>
<ul>
<li><a href="#Authors">Authors and Copyright</a>
<li><a href="#Acknowledgements">Acknowledgments</a>
<li><a href="#Intro">Introduction</a>
    <ul>
    <li><a href="#WhatIs">What is Windows Sockets</a>
    <li><a href="#Berkeley">Berkeley Sockets</a>
    <li><a href="#Windows">Microsoft Windows and Windows-specific extensions</a>
    <li><a href="#Status">The Status of this Specification</a>
    <li><a href="#Revision">Revision History</a>
	<ul>
	<li><a href="#Revision_1.0">Windows Sockets Version 1.0</a>
	<li><a href="#Revision_1.1">Windows Sockets Version 1.1</a>
	</ul>
    </ul>
<li><a href="#ProgrammingWithSockets">Programming with Sockets</a>
    <ul>
    <li><a href="#Prog_StackInstall">Windows Sockets Stack Installation Checking</a>
    <li><a href="#Prog_Sockets">Sockets</a>
	<ul>
	<li><a href="#Sockets_BasicConcepts">Basic concepts</a>
	<li><a href="#Sockets_ClientServer">Client-server model</a>
	<li><a href="#Sockets_OutOfBand">Out-of-band data</a>
	<li><a href="#Sockets_Broadcasting">Broadcasting</a>
	</ul>
    <li><a href="#Prog_ByteOrdering">Byte Ordering</a>
    <li><a href="#Prog_SocketOptions">Socket Options</a>
    <li><a href="#Prog_DatabaseFiles">Database Files</a>
    <li><a href="#Prog_Deviation">Deviation from Berkeley Sockets</a>
	<ul>
	<li><a href="#Deviation_DataType">socket data type and error values</a>
	<li><a href="#Deviation_Select">select() and FD_*</a>
	<li><a href="#Deviation_ErrorCodes">Error codes - errno, h_errno &amp; WSAGetLastError()</a>
	<li><a href="#Deviation_Pointers">Pointers</a>
	<li><a href="#Deviation_RenamedFunctions">Renamed functions</a>
	<li><a href="#Deviation_BlockingRoutines">Blocking routines &amp; EINPROGRESS</a>
	<li><a href="#Deviation_MaxSockets">Maximum number of sockets supported</a>
	<li><a href="#Deviation_IncludeFiles">Include files</a>
	<li><a href="#Deviation_ReturnValues">Return values on API failure</a>
	</ul>
    <li><a href="#Prog_RawSockets">Raw Sockets</a>
    <li><a href="#Prog_MultithreadedWindows">Windows Sockets in Multithreaded Versions of Windows</a>
    </ul>
<li><a href="#SocketLibraryOverview">Socket Library Overview</a>
    <ul>
    <li><a href="#Overview_SocketFunctions">Socket Functions</a>
	<ul>
	<li><a href="#Overview_BlockingNonBlocking">Blocking/Non blocking &amp; Data Volatility</a>
	</ul>
    <li><a href="#Overview_DatabaseFunctions">Database Functions</a>
    <li><a href="#Overview_WindowsSpecific">Microsoft Windows-specific Extension Functions</a>
	<ul>
	<li><a href="#Windows_AsyncSelect">Asynchronous select() Mechanism</a>
	<li><a href="#Windows_AsyncSupport">Asynchronous Support Routines</a>
	<li><a href="#Windows_HookingBlocking">Hooking Blocking Methods</a>
	<li><a href="#Windows_ErrorHandling">Error Handling</a>
	<li><a href="#Windows_Intermediate">Accessing a Windows Sockets DLL from an Intermediate DLL</a>
	<li><a href="#Windows_InternalMessages">Internal use of Messages by Windows Sockets Implementations</a>
	<li><a href="#Windows_PrivateAPIs">Private API Interfaces</a>
	</ul>
    </ul>
<li><a href="#SocketLibraryReference">Socket Library Reference</a>
    <ul>
    <li><a href="#Ref_SocketRoutines">Socket Routines</a>
	<ul>
	<li><a href="#Accept">accept()</a>
	<li><a href="#Bind">bind()</a>
	<li><a href="#CloseSocket">closesocket()</a>
	<li><a href="#Connect">connect()</a>
	<li><a href="#GetPeerName">getpeername()</a>
	<li><a href="#GetSockName">getsockname()</a>
	<li><a href="#GetSockOpt">getsockopt()</a>
	<li><a href="#HtoNL">htonl()</a>
	<li><a href="#HtoNS">htons()</a>
	<li><a href="#InetAddr">inet_addr()</a>
	<li><a href="#InetNtoA">inet_ntoa()</a>
	<li><a href="#IOCTLSocket">ioctlsocket()</a>
	<li><a href="#Listen">listen()</a>
	<li><a href="#NtoHL">ntohl()</a>
	<li><a href="#NtoHS">ntohs()</a>
	<li><a href="#Recv">recv()</a>
	<li><a href="#RecvFrom">recvfrom()</a>
	<li><a href="#Select">select()</a>
	<li><a href="#Send">send()</a>
	<li><a href="#SendTo">sendto()</a>
	<li><a href="#SetSockOpt">setsockopt()</a>
	<li><a href="#ShutDown">shutdown()</a>
	<li><a href="#Socket">socket()</a>
	</ul>
    <li><a href="#Ref_DatabaseRoutines">Database Routines</a>
	<ul>
	<li><a href="#GetHostByAddr">gethostbyaddr()</a>
	<li><a href="#GetHostByName">gethostbyname()</a>
	<li><a href="#GetHostName">gethostname()</a>
	<li><a href="#GetProtoByName">getprotobyname()</a>
	<li><a href="#GetProtoByNumber">getprotobynumber()</a>
	<li><a href="#GetServByName">getservbyname()</a>
	<li><a href="#GetServByPort">GetServByPort()</a>
	</ul>
    <li><a href="#Ref_WindowsExtensions">Microsoft Windows-specific Extensions</a>
	<ul>
	<li><a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a>
	<li><a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a>
	<li><a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a>
	<li><a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a>
	<li><a href="#AsyncGetServByName">WSAAsyncGetServByName()</a>
	<li><a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a>
	<li><a href="#AsyncSelect">WSAAsyncSelect()</a>
	<li><a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
	<li><a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
	<li><a href="#Cleanup">WSACleanup()</a>
	<li><a href="#GetLastError">WSAGetLastError()</a>
	<li><a href="#IsBlocking">WSAIsBlocking()</a>
	<li><a href="#SetBlockingHook">WSASetBlockingHook()</a>
	<li><a href="#SetLastError">WSASetLastError()</a>
	<li><a href="#Startup">WSAStartup()</a>
	<li><a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>
	</ul>
    </ul>
<li><a href="#Appendices">Appendices</a>
    <ul>
    <li><a href="#ErrorsAndHeaders">Error Codes and Header Files</a>
	<ul>
	<li><a href="#ErrorCodes">Error Codes</a>
	<li><a href="#HeaderFiles">Header Files</a>
	    <ul>
	    <li><a href="#BerkeleyHeaders">Berkeley Header Files</a>
	    <li><a href="#WinsockH">Windows Sockets Header File - winsock.h</a>
	    </ul>
	</ul>
    <li><a href="#NotesForSuppliers">Notes for Windows Sockets Suppliers</a>
	<ul>
	<li><a href="#Notes_Introduction">Introduction</a>
	<li><a href="#Notes_WindowsComponents">Windows Sockets Components</a>
	    <ul>
	    <li><a href="#NotesComp_Development">Development Components</a>
	    <li><a href="#NotesComp_RunTime">Run Time Components</a>
	    </ul>
	<li><a href="#Notes_Multithreadedness">Multithreadedness and blocking routines.</a>
	<li><a href="#Notes_DatabaseFiles">Database Files</a>
	<li><a href="#Notes_FDISSET">FD_ISSET</a>
	<li><a href="#Notes_ErrorCodes">Error Codes</a>
	<li><a href="#Notes_DLLOrdinals">DLL Ordinal Numbers</a>
	<li><a href="#Notes_Validation">Validation Suite</a>
	</ul>
    <li><a href="#FurtherReference">For Further Reference</a>
    <li><a href="#Background">Background Information</a>
	<ul>
	<li><a href="#Origins">Origins of Windows Sockets</a>
	<li><a href="#LegalStatus">Legal Status of Windows Sockets</a>
	<li><a href="#IconStory">The Story Behind the Windows Sockets Icon</a>
	</ul>
    </ul>
</ul>

<hr><h1><a name="Authors">Authors and Copyright</a></h1>

<h2><A HREF="mailto:MartinH@JSBUS.Com">Martin Hall</A><BR>
<A HREF="mailto:Towfiq@East.Sun.Com">Mark Towfiq</A><BR>
<A HREF="mailto:Geoff@East.Sun.Com">Geoff Arnold</A><BR>
<A HREF="mailto:DavidTr@Microsoft.Com">David Treadwell</A><BR>
<A HREF="mailto:HenrySa@Microsoft.Com">Henry Sanders</A></h2>

<h3>Copyright (c) 1992 by Martin Hall, Mark Towfiq<br>
Geoff Arnold, David Treadwell and Henry Sanders</h3>

<h3>All rights reserved.</h3>

<p>
This document may be freely redistributed in any form, electronic or otherwise,
provided that it is distributed in its entirety and that the copyright and this
notice are included.  Comments or questions may be submitted via electronic
mail to <A HREF="mailto:WinSock@MailBag.Intel.Com"><I>WinSock@MailBag.Intel.Com</I></A>.  Requests to be added to the Windows
Sockets mailing list should be addressed to <A HREF="mailto:MajorDomo@MailBag.Intel.Com"><I>MajorDomo@MailBag.Intel.Com</I></A>.
This specification, archives of the mailing list, and other information on
Windows Sockets are available via anonymous FTP from the host
<A HREF="ftp://SunSite.UNC.Edu/pub/micro/pc-stuff/ms-windows/winsock"><I>SunSite.UNC.Edu</I>, directory /pub/micro/pc-stuff/ms-windows/winsock</A>.
Questions about products conforming to this specification should be addressed
to the vendors of the products.<p>

<hr><h1>
<a name="Acknowledgements">Acknowledgments</a></h1>
<p>
The authors would like to thank their companies for allowing them the time and
resources to make this specification possible:  JSB Corporation, Microdyne
Corporation, FTP Software, Sun Microsystems, and Microsoft Corporation.<p>

Special thanks should also be extended to the other efforts contributing to the
success of Windows Sockets. The original draft was heavily influenced by
existing specifications offered and detailed by JSB Corporation and NetManage,
Inc. The "version 1.0 debate" hosted by Microsoft in Seattle allowed many of
the members of the working group to hash out final details for 1.0 vis-a-vis.
<p>
Sun Microsystems was kind enough to allow first time implementors to "plug and
play" beta software during the first Windows Sock-A-Thon of  Windows Sockets
applications and implementations at Interop Fall '92.  Microsoft has shared
WSAT (the Windows Sockets API Tester) with other Windows Sockets implementors
as a standard Windows Sockets test suite to aid in testing their
implementations. Finally, Sun Microsystems and FTP Software plan to host the
Windows Sock-A-Thon II in Boston February '93. <p>

Without the contributions of the individuals and corporations involved in the
working group, Windows Sockets would never have been as thoroughly reviewed and
completed as quickly. In just one year, several competitors in the networking
business developed a useful specification with something to show for it! Many
thanks to all which participated, either in person or on e-mail to the Windows
Sockets effort. The authors would like to thank everyone who participated in
any way, and apologize in advance for anyone we have omitted. <p>

List of contributors:<p>
<pre>

Martin Hall 	(Chairman)	JSB Corporation		<A HREF="mailto:martinh@jsbus.com">martinh@jsbus.com</A>
<A HREF="http://SunSite.UNC.Edu/towfiq">Mark Towfiq</A> 	(Coordinator)	Microdyne Corporation	<A HREF="mailto:towfiq@east.sun.com">towfiq@microdyne.com</A>
Geoff Arnold 	(Editor 1.0)	Sun Microsystems	<A HREF="mailto:geoff@east.sun.com">geoff@east.sun.com</A>
David Treadwell	(Editor 1.1)	Microsoft Corporation	<A HREF="mailto:davidtr@microsoft.com">davidtr@microsoft.com</A>
Henry Sanders			Microsoft Corporation	<A HREF="mailto:henrysa@microsoft.com">henrysa@microsoft.com</A>
<p>
J. Allard			Microsoft Corporation	<A HREF="mailto:jallard@microsoft.com">jallard@microsoft.com</A>
Chris Arap-Bologna		Distinct		<A HREF="mailto:chris@distinct.com">chris@distinct.com</A>
Larry Backman			FTP Software		<A HREF="mailto:backman@ftp.com">backman@ftp.com</A>
Alistair Banks			Microsoft Corporation	<A HREF="mailto:alistair@microsoft.com">alistair@microsoft.com</A>
Rob Barrow			JSB Corporation		<A HREF="mailto:robb@jsb.co.uk">robb@jsb.co.uk</A>
Carl Beame			Beame &amp; Whiteside	<A HREF="mailto:beame@mcmaster,ca">beame@mcmaster,ca</A>
Dave Beaver			Microsoft Corporation	<A HREF="mailto:dbeaver@microsoft.com">dbeaver@microsoft.com</A>
Amatzia BenArtzi		NetManage, Inc.		<A HREF="mailto:amatzia@netmanage.com">amatzia@netmanage.com</A>
Mark Beyer			Ungermann-Bass		<A HREF="mailto:mbeyer@ub.com">mbeyer@ub.com</A>
Nelson Bolyard			Silicon Graphics, Inc.	<A HREF="mailto:nelson@sgi.com">nelson@sgi.com</A>
Pat Bonner			Hewlett-Packard		<A HREF="mailto:p_bonner@cnd.hp.com">p_bonner@cnd.hp.com</A>
Derek Brown			FTP Software		<A HREF="mailto:db@wco.ftp.com">db@wco.ftp.com</A>
Malcolm Butler			ICL			<A HREF="mailto:mcab@oasis.icl.co.uk">mcab@oasis.icl.co.uk</A>
Mike Calbaum			Frontier Technologies	<A HREF="mailto:mike@frontiertech.com">mike@frontiertech.com</A>
Isaac Chan			Microsoft Corporation	<A HREF="mailto:isaacc@microsoft.com">isaacc@microsoft.com</A>
Khoji Darbani			Informix		<A HREF="mailto:khoji@informix.com">khoji@informix.com</A>
Nestor Fesas			Hughes LAN Systems	<A HREF="mailto:nestor@hls.com">nestor@hls.com</A>
Karanja Gakio			FTP Software		<A HREF="mailto:karanja@ftp.com">karanja@ftp.com</A>
Vikas Garg			Distinct		<A HREF="mailto:vikas@distinct.com">vikas@distinct.com</A>
Gary Gere			Gupta			<A HREF="mailto:ggere@gupta.com">ggere@gupta.com</A>
Jim Gilroy			Microsoft Corporation	<A HREF="mailto:jamesg@microsoft.com">jamesg@microsoft.com</A>
Bill Hayes			Hewlett-Packard		<A HREF="mailto:billh@hpchdpc.cnd.hp.com">billh@hpchdpc.cnd.hp.com</A>
Paul Hill			MIT			<A HREF="mailto:pbh@athena.mit.edu">pbh@athena.mit.edu</A>
Tmima Koren			NetManage, Inc.		<A HREF="mailto:tmima@netmanage.com">tmima@netmanage.com</A>
Hoek Law			Citicorp		<A HREF="mailto:law@dcc.tti.com">law@dcc.tti.com</A>
Graeme Le Roux			Moresdawn P/L		-
Kevin Lewis			Novell			<A HREF="mailto:kevinl@novell.com">kevinl@novell.com</A>
Roger Lin			3Com			<A HREF="mailto:roger_lin@3mail.3com.com">roger_lin@3mail.3com.com</A>
Terry Lister			Hewlett-Packard		<A HREF="mailto:tel@cnd.hp.com">tel@cnd.hp.com</A>
Jeng Long Jiang			Wollongong		<A HREF="mailto:long@twg.com">long@twg.com</A>
Lee Murach			Network Research	<A HREF="mailto:lee@nrc.com">lee@nrc.com</A>
Pete Ostenson			Microsoft Corporation	<A HREF="mailto:peteo@microsoft.com">peteo@microsoft.com</A>
David Pool			Spry, Inc.		<A HREF="mailto:dave@spry.com">dave@spry.com</A>
Bob Quinn			FTP Software		<A HREF="mailto:rcq@ftp.com">rcq@ftp.com</A>
Glenn Reitsma			Hughes LAN Systems	<A HREF="mailto:glennr@hls.com">glennr@hls.com</A>
Brad Rice			Age			<A HREF="mailto:rice@age.com">rice@age.com</A>
Allen Rochkind			3Com			-
Jonathan Rosen			IBM			<A HREF="mailto:jrosen@vnet.ibm.com">jrosen@vnet.ibm.com</A>
Steve Stokes			Novell			<A HREF="mailto:stoke@novell.com">stoke@novell.com</A>
Joseph Tsai			3Com			<A HREF="mailto:joe_tsai@3mail.3com.com">joe_tsai@3mail.3com.com</A>
James Van Bokkelen		FTP Software		<A HREF="mailto:jbvb@ftp.com">jbvb@ftp.com</A>
Miles Wu			Wollongong		<A HREF="mailto:wu@twg.com">wu@twg.com</A>
Boris Yanovsky			NetManage, Inc.		<A HREF="mailto:boris@netmanage.com">boris@netmanage.com</A>
</pre>

<hr><h1><a name="Intro">Introduction</a></h1>

<hr><h2><a name="WhatIs">What is Windows Sockets</a></h2>

The Windows Sockets specification defines a network programming interface for
Microsoft Windows which is based on the "socket" paradigm popularized in the
Berkeley Software Distribution (BSD) from the University of California at
Berkeley.  It encompasses both familiar Berkeley socket style routines and a
set of Windows-specific extensions designed to allow the programmer to take
advantage of the message-driven nature of Windows.<p>

The Windows Sockets Specification is intended to provide a single API to which
application developers can program and multiple network software vendors can
conform.  Furthermore, in the context of a particular version of Microsoft
Windows, it defines a binary interface (ABI) such that an application written
to the Windows Sockets API can work with a conformant protocol implementation
from any network software vendor.  This specification thus defines the library
calls and associated semantics to which an application developer can program
and which a network software vendor can implement.<p>

Network software which conforms to this Windows Sockets specification will be
considered "Windows Sockets Compliant".  Suppliers of interfaces which are
"Windows Sockets Compliant" shall be referred to as "Windows Sockets
Suppliers".  To be Windows Sockets Compliant, a vendor must implement 100% of
this Windows Sockets specification.<p>

Applications which are capable of operating with any "Windows Sockets
Compliant" protocol implementation will be considered as having a "Windows
Sockets Interface" and will be referred to as "Windows Sockets Applications".<p>

This version of the Windows Sockets specification defines and documents the use
of the API in conjunction with the Internet Protocol Suite (IPS, generally
referred to as TCP/IP).  Specifically, all Windows Sockets implementations
support both stream (TCP) and datagram (UDP) sockets.<p>

While the use of this API with alternative protocol stacks is not precluded
(and is expected to be the subject of future revisions of the specification),
such usage is beyond the scope of this version of the specification.<p>

<hr><h2><a name="Berkeley">Berkeley Sockets</a></h2>

The Windows Sockets Specification has been built upon the Berkeley Sockets
programming model which is the de facto standard for TCP/IP networking.  It is
intended to provide a high degree of familiarity for programmers who are used
to programming with sockets in UNIX and other environments, and to simplify the
task of porting existing sockets-based source code.  The Windows Sockets API is
consistent with release 4.3 of the Berkeley Software Distribution (4.3BSD).<p>

Portions of the Windows Sockets specification are derived from material which
is Copyright (c) 1982-1986 by the Regents of the University of California.  All
rights are reserved.  The Berkeley Software License Agreement specifies the
terms and conditions for redistribution.<p>


<hr><h2><a name="Windows">Microsoft Windows and Windows-specific extensions</a></h2>

This API is intended to be usable within all implementations and versions of
Microsoft Windows from Microsoft Windows Version 3.0 onwards.  It thus provides
for Windows Sockets implementations and Windows Sockets applications in both 16
and 32 bit operating environments.  <p>

Windows Sockets makes provisions for multithreaded Windows processes.  A
process contains one or more threads of execution.  In the Windows 3.1
non-multithreaded world, a task corresponds to a process with a single thread.
All references to threads in this document refer to actual "threads" in
multithreaded Windows environments.  In non multithreaded environments (such as
Windows 3.0), use of the term thread refers to a Windows process.<p>

The Microsoft Windows extensions included in Windows Sockets are provided to
allow application developers to create software which conforms to the Windows
programming model.  It is expected that this will facilitate the creation of
robust and high-performance applications, and will improve the cooperative
multitasking of applications within non-preemptive versions of Windows.  With
the exception of 
<a href="#Startup">WSAStartup()</a>
and 
<a href="#Cleanup">WSACleanup()</a>
their use is not mandatory.<p>


<hr><h2><a name="Status">The Status of this Specification</a></h2>

Windows Sockets is an independent specification which was created and exists
for the benefit of application developers and network vendors and, indirectly,
computer users. Each published (non-draft) version of this specification
represents a fully workable API for implementation by network vendors and
programming use by application developers. Discussion of this specification and
suggested improvements continue and are welcomed. Such discussion occurs mainly
via the Internet electronic mail forum winsock@microdyne.com. Meetings of
interested parties occur on an irregular basis. Details of these meetings are
publicized to the electronic mail forum.<p>

<hr><h2><a name="Revision">Revision History</a></h2>

<hr><h3><a name="Revision_1.0">Windows Sockets Version 1.0</a></h3>

Windows Sockets Version 1.0 represented the results of considerable work within
the vendor and user community as discussed in "
<a href="#Origins">Origins
of Windows Sockets</a>". This version of  the specification was released in
order that network software suppliers and  application developers could begin
to construct implementations and applications  which conformed to the Windows
Sockets standard.<p>

<hr><h3><a name="Revision_1.1">Windows Sockets Version 1.1</a></h3>

Windows Sockets Version 1.1 follows the guidelines and structure laid out by
version 1.0, making changes only where absolutely necessary as indicated by the
experiences of a number of companies that created Windows Sockets
implementations based on the version 1.0 specification.  Version 1.1 contains
several clarifications and minor fixes to version 1.0.  Additionally, the
following more significant changes were incorporated into version 1.1:
<p>

<ul>
<li> Inclusion of the <a href="#GetHostName">gethostname()</a>
routine to simplify retrieval of the host's name and address.<p>

<li> Definition of DLL ordinal values below 1000 as reserved for Windows Sockets
and ordinals above 1000 as unrestricted.  This allows Windows Sockets vendors
to include private interfaces to their DLLs without risking that the ordinals
choosen will conflict with a future version of Windows Sockets.<p>

<li> Addition of a reference count to <a href="#Startup">WSAStartup()</a> and
<a href="#Cleanup">WSACleanup()</a>, requiring correspondences between the
calls.  This allows applications and third-party DLLs to make use of a Windows
Sockets implementation without being concerned about the calls to these APIs
made by the other.<p>

<li> Change of return type of <a href="#InetAddr">inet_addr()</a> from
<b>struct in_addr</b> to <b>unsigned long</b>.  This was required due to
different handling of four-byte structure returns between the Microsoft and
Borland C compilers.<p>

<li> Change of <a href="#AsyncSelect">WSAAsyncSelect()</a> semantics
from "edge-triggerred" to "level-triggerred".  The level-triggerred semantics
significantly simplify an application's use of this routine.<p>

<li> Change the <a href="#IoctlSocket">ioctlsocket()</a> FIONBIO
semantics to fail if a <a href="#AsyncSelect">WSAAsyncSelect()</a> call
is outstanding on the socket.<p>

<li> Addition of the TCP_NODELAY socket option for RFC 1122 conformance.
</ul>

<hr><h1><a name="ProgrammingWithSockets">Programming with Sockets</a></h1>

<hr><h2><a name="Prog_StackInstall">Windows Sockets Stack Installation Checking</a></h2>

To detect the presence of one (or many) Windows Sockets implementations on a
system, an application which has been linked with the Windows Sockets Import
Library may simply call the 
<a href="#Startup">WSAStartup()</a>
routine.  If an application wishes to be a little more sophisticated it can
examine the $PATH environment variable and search for instances of Windows
Sockets implementations (WINSOCK.DLL).  For each instance it can issue a
<b>LoadLibrary()</b> call and use the 
<a href="#Startup">WSAStartup()</a>
routine to discover implementation specific data.<p>

This version of the Windows Sockets specification does not attempt to address
explicitly the issue of multiple concurrent Windows Sockets implementations.
Nothing in the specification should be interpreted as restricting multiple
Windows Sockets DLLs from being present and used concurrently by one or more
Windows Sockets applications.<p>

For further details of where to obtain Windows Sockets components, see "
<a href="#Notes_WindowsComponents">Windows
Sockets Components</a>".<p>

<hr><h2><a name="Prog_Sockets">Sockets</a></h2>

The following material is derived from the document "An Advanced 4.3BSD
Interprocess Communication Tutorial" by Samuel J. Leffler, Robert S. Fabry,
William N. Joy, Phil Lapsley, Steve Miller, and Chris Torek.<p>

<hr><h3><a name="Sockets_BasicConcepts">Basic concepts</a></h3>

The basic building block for communication is the socket.  A socket is an
endpoint of communication to which a name may be bound.  Each socket in use has
a type and an associated process.  Sockets exist within communication domains.
A communication domain is an abstraction introduced to bundle common properties
of threads communicating through sockets.  Sockets normally exchange data only
with sockets in the same domain (it may be possible to cross domain boundaries,
but only if some translation process is performed).  The Windows Sockets
facilities support a single communication domain: the Internet domain, which is
used by processes which communicate using the Internet Protocol Suite.  (Future
versions of this specification may include additional domains.) <p>

Sockets are typed according to the communication properties visible to a user.
Applications are presumed to communicate only between sockets of the same type,
although there is nothing that prevents communication between sockets of
different types should the underlying communication protocols support this.  <p>

Two types of sockets currently are available to a user.  A stream socket
provides for the bi-directional, reliable, sequenced, and unduplicated flow of
data without record boundaries.  <p>

A datagram socket supports bi-directional flow of data which is not promised to
be sequenced, reliable, or unduplicated.  That is, a process receiving messages
on a datagram socket may find messages duplicated, and, possibly, in an order
different from the order in which it was sent.  An important characteristic of
a datagram socket is that record boundaries in data are preserved.  Datagram
sockets closely model the facilities found in many contemporary packet switched
networks such as Ethernet.  <p>


<hr><h3><a name="Sockets_ClientServer">Client-server model</a></h3>

The most commonly used paradigm in constructing distributed applications is the
client/server model.  In this scheme client applications request services from
a server application.  This implies an asymmetry in establishing communication
between the client and server.  <p>

The client and server require a well-known set of conventions before service
may be rendered (and accepted).  This set of conventions comprises a protocol
which must be implemented at both ends of a connection.  Depending on the
situation, the protocol may be symmetric or asymmetric.  In a symmetric
protocol, either side may play the master or slave roles.  In an asymmetric
protocol, one side is immutably recognized as the master, with the other as the
slave.  An example of a symmetric protocol is the TELNET protocol used in the
Internet for remote terminal emulation.  An example of an asymmetric protocol
is the Internet file transfer protocol, FTP.  No matter whether the specific
protocol used in obtaining a service is symmetric or asymmetric, when accessing
a service there is a ``client process'' and a ``server process''.  <p>

A server application normally listens at a well-known address for service
requests.  That is, the server process remains dormant until a connection is
requested by a client's connection to the server's address.  At such a time the
server process ``wakes up'' and services the client, performing whatever
appropriate actions the client requests of it.  While connection-based services
are the norm, some services are based on the use of datagram sockets.  <p>


<hr><h3><a name="Sockets_OutOfBand">Out-of-band data</a></h3>

Note: The following discussion of out-of-band data, also referred to as TCP
Urgent data,  follows the model used in the Berkeley software distribution.
Users and implementors should be aware of the fact that there are at present
two conflicting interpretations of RFC 793 (in which the concept is
introduced), and that the implementation of out-of-band data in the Berkeley
Software Distribution does not conform to the Host Requirements laid down in
RFC 1122.  To minimize interoperability problems, applications writers are
advised not to use out-of-band data unless this is required in order to
interoperate with an existing service.  Windows Sockets suppliers are urged to
document the out-of-band semantics (BSD or RFC 1122) which their product
implements.  It is beyond the scope of this specification to mandate a
particular set of semantics for out-of-band data handling.<p>

The stream socket abstraction includes the notion of ``out of band'' data.
Out-of-band data is a logically independent transmission channel associated
with each pair of connected stream sockets.  Out-of-band data is delivered to
the user independently of normal data.  The abstraction defines that the
out-of-band data facilities must support the reliable delivery of at least one
out-of-band message at a time.  This message may contain at least one byte of
data, and at least one message may be pending delivery to the user at any one
time.  For communications protocols which support only in-band signaling (i.e.
the urgent data is delivered in sequence with the normal data), the system
normally extracts the data from the normal data stream and stores it
separately.  This allows users to choose between receiving the urgent data in
order and receiving it out of sequence without having to buffer all the
intervening data.  It is possible to ``peek'' at out-of-band data.  <p>

An application may prefer to process out-of-band data "in-line", as part of the
normal data stream.  This is achieved by setting the socket option SO_OOBINLINE
(see 
<a href="#SetSockOpt">setsockopt()</a>).
In this case, the application may wish to determine whether any of the unread
data is "urgent" (the term usually applied to in-line out-of-band data).  To
facilitate this, the Windows Sockets implementation will maintain a logical
"mark" in the data stream to indicate the point at which the out-of-band data
was sent.  An application can use the SIOCATMARK 
<a href="#IOCTLSocket">ioctlsocket()</a>
command to determine whether there is any unread data preceding the mark.  For
example, it might use this to resynchronize with its peer by ensuring that all
data up to the mark in the data stream is discarded when appropriate.<p>

The 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
routine is particularly well suited to handling notification of the presence of
out-of-band-data.<p>


<hr><h3><a name="Sockets_Broadcasting">Broadcasting</a></h3>

By using a datagram socket, it is possible to send broadcast packets on many
networks supported by the system.  The network itself must support broadcast:
the system provides no simulation of broadcast in software.  Broadcast messages
can place a high load on a network, since they force every host on the network
to service them.  Consequently, the ability to send broadcast packets has been
limited to sockets which are explicitly marked as allowing broadcasting.
Broadcast is typically used for one of two reasons: it is desired to find a
resource on a local network without prior knowledge of its address, or
important functions such as routing require that information be sent to all
accessible neighbors.<p>

The destination address of the message to be broadcast depends on the
network(s) on which the message is to be broadcast.  The Internet domain
supports a shorthand notation for broadcast on the local network, the address
INADDR_BROADCAST.  Received broadcast messages contain the senders address and
port, as datagram sockets must be bound before use.<p>

Some types of network support the notion of different types of broadcast.  For
example, the IEEE 802.5 token ring architecture supports the use of link-level
broadcast indicators, which control whether broadcasts are forwarded by
bridges.  The Windows Sockets specification does not provide any mechanism
whereby an application can determine the type of underlying network, nor any
way to control the semantics of broadcasting.<p>


<hr><h2><a name="Prog_ByteOrdering">Byte Ordering</a></h2>

The Intel byte ordering is like that of the DEC VAX, and therefore differs from
the Internet and 68000-type processor byte ordering.  Thus care must be taken
to ensure correct orientation.<p>

Any reference to IP addresses or port numbers passed to or from a Windows
Sockets routine must be in network order.  This includes the IP address and
port fields of a <b>struct sockaddr_in</b> (but not the <i>sin_family</i>
field).<p>

Consider an application which normally contacts a server on the TCP port
corresponding to the "time" service, but which provides a mechanism for the
user to specify that an alternative port is to be used.  The port number
returned by 
<a href="#GetServByName">getservbyname()</a>
is already in network order, which is the format required constructing an
address, so no translation is required.  However if the user elects to use a
different port, entered as an integer, the application must convert this from
host to network order (using the 
<a href="#HtoNS">htons()</a>
function) before using it to construct an address.  Conversely, if the
application wishes to display the number of the port within an address
(returned via, e.g., 
<a href="#GetPeerName">getpeername()</a>),
the port number must be converted from network to host order (using 
<a href="#NtoHS">ntohs()</a>)
before it can be displayed.<p>

Since the Intel and Internet byte orders are different, the conversions
described above are unavoidable.  Application writers are cautioned that they
should use the standard conversion functions provided as part of the Windows
Sockets API rather than writing their own conversion code, since future
implementations of Windows Sockets are likely to run on systems for which the
host order is identical to the network byte order.  Only applications which use
the standard conversion functions are likely to be portable.<p>


<hr><h2><a name="Prog_SocketOptions">Socket Options</a></h2>

The socket options supported by Windows Sockets are listed in the pages
describing 
<a href="#SetSockOpt">setsockopt()</a>
and 
<a href="#GetSockOpt">getsockopt()</a>.
A Windows Sockets implementation must recognize all of these options, and (for 
<a href="#GetSockOpt">getsockopt()</a>)
return plausible values for each.  The default value for each option is shown
in the following table.

<pre>
<b><u>Value		Type		Meaning			Default		Note</u></b>
--------------- --------------- ----------------------- --------------- ----
SO_ACCEPTCON	BOOL		Socket is <a href="#Listen">listen()</a>ing.
				FALSE unless a <a href="#Listen">listen()</a>
				has been performed<p>

SO_BROADCAST	BOOL		Socket is configured	FALSE<p>
				for the transmission of<p>
				broadcast messages.	<p>

SO_DEBUG	BOOL		Debugging is enabled.  	FALSE		(i)<p>

SO_DONTLINGER	BOOL		If true, the SO_LINGER	TRUE<p>
				option is disabled..		<p>

SO_DONTROUTE	BOOL		Routing is disabled.	FALSE		(i)<p>

SO_ERROR	int		Retrieve error status	0<p>
				and clear.	<p>

SO_KEEPALIVE	BOOL		Keepalives are being	FALSE<p>
				sent.	<p>

SO_LINGER	struct linger	Returns the current	<i>l_onoff</i> is 0<p>
		FAR *		linger options.<p>

SO_OOBINLINE	BOOL		Out-of-band data is	FALSE<p>
				being received in the<p>
				normal data stream.	<p>

SO_RCVBUF	int		Buffer size for		Implementation	(i)<p>
				receives		dependant.<p>

SO_REUSEADDR	BOOL		The address to which	FALSE<p>
				this socket is bound<p>
				can be used by others.	<p>

SO_SNDBUF	int		Buffer size for sends	Implementation	(i)<p>
							dependant.<p>

SO_TYPE		int		The type of the socket	As created<p>
				(e.g. SOCK_STREAM).	via <a href="#Socket">socket()</a><p>

TCP_NODELAY	BOOL		Disables the Nagle	Implementation<p>
				algorithm for send	dependant.<p>
				coalescing.
</pre>
<p>Notes:<p>
(i)	An implementation may silently ignore this option on 
<a href="#SetSockOpt">setsockopt()</a>
and return a constant value for 
<a href="#GetSockOpt">getsockopt()</a>,
or it may accept a value for 
<a href="#SetSockOpt">setsockopt()</a>
and return the corresponding value in 
<a href="#GetSockOpt">getsockopt()</a>
without using the value in any way.
<p>

<hr><h2><a name="Prog_DatabaseFiles">Database Files</a></h2>

The 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
and 
<a href="#Overview_DatabaseFunctions">WSAAsyncGetXByY()</a>
classes of routines are provided for retrieving network specific information.
The <b>getXbyY()</b> routines were originally designed (in the first Berkeley
UNIX releases) as mechanisms for looking up information in text databases.
Although the information may be retrieved by the Windows Sockets implementation
in different ways, a Windows Sockets application requests such information in a
consistent manner through either the <b>getXbyY()</b> or the
<b>WSAAsyncGetXByY()</b> class of routines.<p>


<hr><h2><a name="Prog_Deviation">Deviation from Berkeley Sockets</a></h2>

There are a few limited instances where the Windows Sockets API has had to
divert from strict adherence to the Berkeley conventions, usually because of
difficulties of implementation in a Windows environment.<p>

<a href="#Deviation_DataType">socket
data type and error values</a><p>
<a href="#Deviation_Select">select()
and FD_*</a><p>
<a href="#Deviation_ErrorCodes">Error
codes -- errno, h_errno &amp; WSAGetLastError()</a><p>
<a href="#Deviation_Pointers">Pointers</a><p>
<a href="#Deviation_RenamedFunctions">Renamed
functions</a><p>
<a href="#Deviation_BlockingRoutines">Blocking
routines &amp; EINPROGRESS</a><p>
<a href="#Deviation_MaxSockets">Maximum
number of sockets supported</a><p>
<a href="#Deviation_IncludeFiles">Include
files</a><p>
<a href="#Deviation_ReturnValues">Return
values on API failure</a><p>

<p>

<hr><h3><a name="Deviation_DataType">socket data type and error values</a></h3>

A new data type, SOCKET, has been defined.  The definition of this type was
necessary for future enhancements to the Windows Sockets specification, such as
being able to use sockets as file handles in Windows NT.  Definition of this
type also facilitates porting of applications to a Win/32 environment, as the
type will automatically be promoted from 16 to 32 bits.<p>

In UNIX, all handles, including socket handles, are small, non-negative
intergers, and some applications make assumptions that this will be true.
Windows Sockets handles have no restrictions, other than that the value
INVALID_SOCKET is not a valid socket.  Socket handles may take any value in the
range 0 to INVALID_SOCKET-1.<p>

Because the SOCKET type is unsigned, compiling existing source code from, for
example, a UNIX environment may lead to compiler warnings about signed/unsigned
data type mismatches.<p>

This means, for example, that checking for errors when the 
<a href="#Socket">socket()</a>
and 
<a href="#Accept">accept()</a>
routines return should <u>not</u> be done by comparing the return value with
-1, or seeing if the value is negative (both common, and legal, approaches in
BSD).  Instead, an application should use the manifest constant INVALID_SOCKET
as defined in 
<a href="#WinsockH">winsock.h</a>.
For example:<p>
	<b>TYPICAL BSD STYLE:</b>

<pre>
s = socket(...);
if (s == -1)	/* or s &lt; 0 */
	{...}
</pre>
<p>
	<b>PREFERRED STYLE:</b>

<pre>
s = socket(...);
if (s == INVALID_SOCKET)
	{...}
</pre>
<p>

<hr><h3><a name="Deviation_Select">select() and FD_*</a></h3>

Because a SOCKET is no longer represented by the UNIX-style "small non-negative
integer", the implementation of the 
<a href="#Select">select()</a>
function was changed in the Windows Sockets API.  Each set of descriptors is
still represented by the fd_set type, but instead of being stored as a bitmask
the set is implemented as an array of SOCKETs..  To avoid potential problems,
applications <b>must</b> adhere to the use of the FD_XXX macros to set,
initialize, clear, and check the fd_set structures.<p>


<hr><h3><a name="Deviation_ErrorCodes">Error codes -- errno, h_errno &amp; WSAGetLastError()</a></h3>

Error codes set by the Windows Sockets implementation are <b>NOT</b> made
available via the errno variable.  Additionally, for the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
class of functions, error codes are <b>NOT</b> made available via the h_errno
variable.  Instead, error codes are accessed by using the 
<a href="#GetLastError">WSAGetLastError()</a>
API.  This function is provided in Windows Sockets as a precursor (and
eventually an alias) for the Win32 function <b>GetLastError()</b>.  This is
intended to provide a reliable way for a thread in a multi-threaded process to
obtain per-thread error information.<p>

For compatibility with BSD, an application may choose to include a line of the
form:<p>


<pre>
#define errno WSAGetLastError()
</pre>
<p>
This will allow networking code which was written to use the global errno to
work correctly in a single-threaded environment.  There are, obviously, some
drawbacks.  If a source file includes code which inspects errno for both socket
and non-socket functions, this mechanism cannot be used.  Furthermore, it is
not possible for an application to assign a new value to errno.  (In Windows
Sockets the function 
<a href="#SetLastError">WSASetLastError()</a>
may be used for this purpose.)<p>

	<b>TYPICAL BSD STYLE:</b>

<pre>
r = recv(...);
if (r == -1
    &amp;&amp; errno == EWOULDBLOCK)
	{...}
</pre>
<p>
	<b>PREFERRED STYLE:</b>

<pre>
r = recv(...);
if (r == -1       /* (but see below) */
    &amp;&amp; WSAGetLastError() == EWOULDBLOCK)
	{...}
</pre>
Although
error constants consistent with 4.3 Berkeley Sockets are provided for
compatibility purposes, applications should, where possible, use the "WSA"
error code definitions.  For example, a more accurate version of the above
source code fragment is:<p>


<pre>
r = recv(...);
if (r == -1
    &amp;&amp; WSAGetLastError() == <A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>)
	{...}
</pre>
<p>

<hr><h3><a name="Deviation_Pointers">Pointers</a></h3>

All pointers used by applications with Windows Sockets should be FAR.  To
facilitate this, data type definitions such as LPHOSTENT are provided.<p>


<hr><h3><a name="Deviation_RenamedFunctions">Renamed functions</a></h3>

In two cases it was necessary to rename functions which are used in Berkeley
Sockets in order to avoid clashes with other APIs.<p>

<b>close() &amp; </b>
<a href="#CloseSocket">closesocket()</a>
In Berkeley Sockets, sockets are represented by standard file descriptors, and
so the <b>close()</b> function can be used to close sockets as well as regular
files.  While nothing in the Windows Sockets API prevents an implementation
from using regular file handles to identify sockets, nothing requires it
either.  Socket descriptors are not presumed to correspond to regular file
handles, and file operations such as <b>read()</b>, <b>write()</b>, and
<b>close()</b> cannot be assumed to work correctly when applied to socket
descriptors..  Sockets must be closed by using the 
<a href="#CloseSocket">closesocket()</a>
routine.  Using the <b>close()</b> routine to close a socket is incorrect and
the effects of doing so are undefined by this specification.<p>

<b>ioctl() &amp; </b>
<a href="#IOCTLSocket">ioctlsocket()</a><p>
Various C language run-time systems use the <b>ioctl()</b> routine for purposes
unrelated to Windows Sockets.  For this reason we have defined the routine 
<a href="#IOCTLSocket">ioctlsocket()</a>
which is used to handle socket functions which in the Berkeley Software
Distribution are performed using <b>ioctl()</b> and <b>fcntl()</b>.<p>


<hr><h3><a name="Deviation_BlockingRoutines">Blocking routines &amp; EINPROGRESS</a></h3>

Although blocking operations on sockets are supported under Windows Sockets,
their use is strongly discouraged.  Programmers who are constrained to use
blocking mode -- for example, as part of an existing application which is to be
ported -- should be aware of the semantics of blocking operations in Windows
Sockets.  See 
<a href="#Overview_BlockingNonBlocking">Blocking/Non
blocking &amp; Data Volatility</a> for more details.<p>


<hr><h3><a name="Deviation_MaxSockets">Maximum number of sockets supported</a></h3>

The maximum number of sockets supported by a particular Windows Sockets
supplier is implementation specific.  An application should make no assumptions
about the availability of a certain number of sockets.  This topic is addressed
further in the section on 
<a href="#Startup">WSAStartup()</a>.
However, independent of the number of sockets supported by a particular
implementation is the issue of the maximum number of sockets which an
application can actually make use of.<p>

The maximum number of sockets which a Windows Sockets application can make use
of is determined at compile time by the manifest constant FD_SETSIZE.  This
value is used in constructing the fd_set structures used in 
<a href="#Select">select()</a>.
The default value in 
<a href="#WinsockH">winsock.h</a>
is 64.  If an application is designed to be capable of working with more than
64 sockets, the implementor should define the manifest FD_SETSIZE in every
source file <u>before</u> including 
<a href="#WinsockH">winsock.h</a>.
One way of doing this may be to include the definition within the compiler
options in the makefile, for example adding -DFD_SETSIZE=128 as an option to
the compiler command line for Microsoft C.  It must be emphasized that defining
FD_SETSIZE as a particular value has no effect on the actual number of sockets
provided by a Windows Sockets implementation.<p>


<hr><h3><a name="Deviation_IncludeFiles">Include files</a></h3>

For ease of portability of existing Berkeley sockets based source code, a
number of standard Berkeley include files are supported.  However, these
Berkeley header files merely include the 
<a href="#WinsockH">winsock.h</a>
include file, and it is therefore sufficient (and recommended) that Windows
Sockets application source files should simply include 
<a href="#WinsockH">winsock.h</a>.<p>


<hr><h3><a name="Deviation_ReturnValues">Return values on API failure</a></h3>

The manifest constant SOCKET_ERROR is provided for checking API failure.
Although use of this constant is not mandatory, it is recommended.  The
following example illustrates the use of the SOCKET_ERROR constant:<p>

<b>	TYPICAL BSD STYLE:</b>

<pre>
r = recv(...);
if (r == -1     /* or r &lt; 0 */
    &amp;&amp; errno == EWOULDBLOCK)
	{...}
</pre>
<b>
PREFERRED STYLE:</b>

<pre>
r = recv(...);
if (r == SOCKET_ERROR
    &amp;&amp; WSAGetLastError() == <A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>)
	{...}
</pre>

<hr><h2><a name="Prog_RawSockets">Raw Sockets</a></h2>

The Windows Sockets specification does not mandate that a Windows Sockets DLL
support raw sockets, that is, sockets opened with SOCK_RAW.  However, a Windows
Sockets DLL is allowed and encouraged to supply raw socket support.  A Windows
Sockets-compliant application that wishes to use raw sockets should attempt to
open the socket with the <b>socket()</b> call (see section 4.1.23), and if it
fails either attempt to use another socket type or indicate the failure to the
user.<p>

<hr><h2><a name="Prog_MultithreadedWindows">Windows Sockets in Multithreaded Versions of Windows</a></h2>

The Windows Sockets interface is designed to work for both single-threaded
versions of Windows (such as Windows 3.1) and future multithreaded versions of
Windows (such as Windows NT).  In a multithreaded environment the sockets
interface is basically the same, but the author of a multithreaded application
must be aware that it is the responsibility of the application, not the Windows
Sockets implementation, to synchronize access to a socket between threads.
This is the same rule as applies to other forms of I/O such as file I/O.
Failure to synchronize calls on a socket leads to unpredictable results; for
example if there are two simultaneous calls to send(), there is no guarantee as
to the order in which the data will be sent.  <p>

Closing a socket in one thread that has an outstanding blocking call on the
same socket in another thread will cause the blocking call to fail with
<A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>, just as if the operation were cancelled.  This also applies if there
is a 
<a href="#Select">select()</a>
call outstanding and the application closes one of the sockets being
selected.<p>

There is no default blocking hook installed in preemptive multithreaded
versions of Windows.  This is because the machine will not be blocked if a
single application is waiting for an operation to complete and hence not
calling PeekMessage() or GetMessage() which cause the application to yield in
nonpremptive Windows.  However, for backwards compatibility the
WSASetBlockingHook() call is implemented in multithreaded versions of Windows,
and any application whose behavior depends on the default blocking hook may
install their own blocking hook which duplicates the default hook's semantics,
if desired.

<hr><h1><a name="SocketLibraryOverview">Socket Library Overview</a></h1>

<hr><h2><a name="Overview_SocketFunctions">Socket Functions</a></h2>

The Windows Sockets specification includes the following Berkeley-style socket
routines:<p>

<a href="#Accept">accept()</a>
An incoming connection is acknowledged and associated with an immediately
created socket.  The original socket is returned to the listening state.<p>
<a href="#Bind">bind()</a>
Assign a local name to an unnamed socket.<p>
<a href="#CloseSocket">closesocket()</a>
Remove a socket descriptor from the per-process object reference table.  Only
blocks if SO_LINGER is set.<p>
<a href="#Connect">connect()</a>
Initiate a connection on the specified socket.<p>
<a href="#GetPeerName">getpeername()</a>
Retrieve the name of the peer connected to the specified socket descriptor.<p>
<a href="#GetSockName">getsockname()</a>
Retrieve the current name for the specified socket<p>
<a href="#GetSockOpt">getsockopt()</a>
Retrieve options associated with the specified socket descriptor.<p>
<a href="#HtoNL">htonl()</a>
Convert a 32-bit quantity from host byte order to network byte order.<p>
<a href="#HtoNS">htons()</a>
Convert a 16-bit quantity from host byte order to network byte order.<p>
<a href="#InetAddr">inet_addr()</a>
Converts a character string representing a number in the Internet standard ``.''
notation to an Internet address value.<p>
<a href="#InetNtoA">inet_ntoa()</a>
Converts an Internet address value to an ASCII string in ``.'' notation i.e.
``a.b.c.d''.<p>
<a href="#IOCTLSocket">ioctlsocket()</a>
Provide control for descriptors.<p>
<a href="#Listen">listen()</a>
Listen for incoming connections on a specified socket.<p>
<a href="#NtoHL">ntohl()</a>
Convert a 32-bit quantity from network byte order to host byte order.<p>
<a href="#NtoHS">ntohs()</a>
Convert a 16-bit quantity from network byte order to host byte order.<p>
<a href="#RECV">recv()*</a>
Receive data from a connected socket.<p>
<a href="#RecvFrom">recvfrom()*</a>
Receive data from either a connected or unconnected socket.<p>
<a href="#Select">select()*</a>
Perform synchronous I/O multiplexing.<p>
<a href="#Send">send()*</a>
Send data to a connected socket.<p>
<a href="#SendTo">sendto()*</a>
Send data to either a connected or unconnected socket.<p>
<a href="#SetSockOpt">setsockopt()</a>
Store options associated with the specified socket descriptor.<p>
<a href="#Shutdown">shutdown()</a>
Shut down part of a full-duplex connection.<p>
<a href="#Socket">socket()</a>
Create an endpoint for communication and return a socket descriptor.<p>

* The routine can block if acting on a blocking socket.<p>

<hr><h3><a name="Overview_BlockingNonBlocking">Blocking/Non blocking &amp; Data Volatility</a></h3>

One major issue in porting applications from a Berkeley sockets environment to
a Windows environment involves "blocking"; that is, invoking a function which
does not return until the associated operation is completed.  The problem
arises when the operation may take an arbitrarily long time to complete: an
obvious example is a 
<a href="#Recv">recv()</a>
which may block until data has been received from the peer system.  The default
behavior within the Berkeley sockets model is for a socket to operate in a
blocking mode unless the programmer explicitly requests that operations be
treated as non-blocking.  <b><i>It is strongly recommended that programmers use
the nonblocking (asynchronous) operations if at all possible, as they work
significantly better within the nonpreemptive Windows environment.  Use
blocking operations only if absolutely necessary, and carefully read and
understand this section if you must use blocking operations.</i></b><p>

Even on a blocking socket, some operations (e.g. 
<a href="#Bind">bind()</a>,
<a href="#GetSockOpt">getsockopt()</a>,
<a href="#GetPeerName">getpeername()</a>)
can be completed immediately.  For such operations there is no difference
between blocking and non-blocking operation.  Other operations (e.g. 
<a href="#Recv">recv()</a>)
may be completed immediately or may take an arbitrary time to complete,
depending on various transport conditions.  When applied to a blocking socket,
these operations are referred to as blocking operations.  All routines which
can block are listed with an asterisk in the tables above and below.<p>

Within a Windows Sockets implementation, a blocking operation which cannot be
completed immediately is handled as follows.  The DLL initiates the operation,
and then enters a loop in which it dispatches any Windows messages (yielding
the processor to another thread if necessary) and then checks for the
completion of the Windows Sockets function.  If the function has completed, or
if 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
has been invoked, the blocking function completes with an appropriate result.
Refer to  
<a href="#SetBlockingHook">WSASetBlockingHook()</a>,
for a complete description of this mechanism, including pseudocode for the
various functions.<p>

If a Windows message is received for a process for which a blocking operation
is in progress, there is a risk that the application will attempt to issue
another Windows Sockets call.  Because of the difficulty of managing this
condition safely, the Windows Sockets specification does not support such
application behavior.  Two functions are provided to assist the programmer in
this situation.  
<a href="#IsBlocking">WSAIsBlocking()</a>
may be called to determine whether or not a blocking Windows Sockets call is in
progress.  
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
may be called to cancel an in-progress blocking call, if any.  <b>Any other
Windows Sockets function which is called in this situation will fail with the
error <A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>.</b>  It should be emphasized that this restriction
applies to both blocking and non-blocking operations.<p>

Although this mechanism is sufficient for simple applications, it cannot
support the complex message-dispatching requirements of more advanced
applications (for example, those using the MDI model).  For such applications,
the Windows Sockets API includes the function 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>,
which allows the programmer to define a special routine which will be called
instead of the default message dispatch routine described above.<p>

The Windows Sockets DLL will call the blocking hook function only if all of the
following are true: the routine is one which is defined as being able to block,
the specified socket is a blocking socket, and the request cannot be completed
immediately.  (A socket is set to blocking by default, but the IOCTL FIONBIO
and  
<a href="#AsyncSelect">WSAAsyncSelect()</a>
both set a socket to nonblocking mode.)  If an application uses only
non-blocking sockets and uses the 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
and/or the 
<a href="#Overview_DatabaseFunctions">WSAAsyncGetXByY()</a>
routines instead of 
<a href="#Select">select()</a>
and the 
<a href="#Overview_DatabaseFunctions">getXbyY()</a>
routines, then the blocking hook will never be called and the application does
not need to be concerned with the reentrancy issues the blocking hook can
introduce.<p>

If an application invokes an asynchronous or non-blocking operation which takes
a pointer to a memory object (e.g. a buffer, or a global variable) as an
argument, it is the responsibility of the application to ensure that the object
is available to the Windows Sockets implementation throughout the operation.
The application must not invoke any Windows function which might affect the
mapping or addressability of the memory involved.  In a multithreaded system,
the application is also responsible for coordinating access to the object using
appropriate synchronization mechanisms.  A Windows Sockets implementation
cannot, and will not, address these issues.  The possible consequences of
failing to observe these rules are beyond the scope of this specification.<p>

<hr><h2><a name="Overview_DatabaseFunctions">Database Functions</a></h2>

The Windows Sockets specification defines the following "database" routines.
As noted earlier, a Windows Sockets supplier may choose to implement these in a
manner which does not depend on local database files.  The pointer returned by
certain database routines such as 
<a href="#GetHostByName">gethostbyname()</a>
points to a structure which is allocated by the Windows Sockets library.  The
data which is pointed to is volatile and is good only until the next Windows
Sockets API call from that thread.  Additionally, the application must never
attempt to modify this structure or to free any of its components.  Only one
copy of this structure is allocated for a thread, and so the application should
copy any information which it needs before issuing any other Windows Sockets
API calls.<p>

<p>
<a href="#GetHostByAddr">gethostbyaddr()*</a>
Retrieve the name(s) and address corresponding to a network address.<p>
<a href="#GetHostName">gethostname()</a>
Retrieve the name of the local host.<p>
<a href="#GetHostByName">gethostbyname()*</a>
Retrieve the name(s) and address corresponding to a host name.<p>
<a href="#GetProtoByName">getprotobyname()*</a>
Retrieve the protocol name and number corresponding to a protocol name.<p>
<a href="#GetProtoByNumber">getprotobynumber()*</a>
Retrieve the protocol name and number corresponding to a protocol number.<p>
<a href="#GetServByName">getservbyname()*</a>
Retrieve the service name and port corresponding to a service name.<p>
<a href="#GetServByPort">getservbyport()*</a>
Retrieve the service name and port corresponding to a port.<p>

* The routine can block under some circumstances.<p>

<hr><h2><a name="Overview_WindowsSpecific">Microsoft Windows-specific Extension Functions</a></h2>

The Windows Sockets specification provides a number of extensions to the
standard set of Berkeley Sockets routines.  Principally, these extended APIs
allow message-based, asynchronous access to network events.  While use of this
extended API set is not mandatory for socket-based programming (with the
exception of 
<a href="#Startup">WSAStartup()</a>
and 
<a href="#Cleanup">WSACleanup()</a>),
it is recommended for conformance with the Microsoft Windows programming
paradigm.<p>

<a href="#Windows_AsyncSelect">Asynchronous
select() Mechanism</a><p>
<a href="#Windows_AsyncSupport">Asynchronous
Support Routines</a><p>
<a href="#Windows_HookingBlocking">Hooking
Blocking Methods</a><p>
<a href="#Windows_ErrorHandling">Error
Handling</a><p>
<a href="#Windows_Intermediate">Accessing
a Windows Sockets DLL from an Intermediate DLL</a><p>
<a href="#Windows_InternalMessage#s">Internal
Use of Messages by Windows Sockets Implementations</a><p>
<a href="#Windows_PrivateAPIs">Private
API Interfaces</a><p>

<p>
<a href="#AsyncGetHostByAddr">WSAAsyncGetHostByAddr()</a>
A set of functions which provide asynchronous<p>
<a href="#AsyncGetHostByName">WSAAsyncGetHostByName()</a>
versions of the standard Berkeley<p>
<a href="#AsyncGetProtoByName">WSAAsyncGetProtoByName()</a>
<b>getXbyY()</b> functions.  For example, the<p>
<a href="#AsyncGetProtoByNumber">WSAAsyncGetProtoByNumber()</a>
<b>WSAAsyncGetHostByName()</b> function provides an asynchronous message
based<p>
<a href="#AsyncGetServByName">WSAAsyncGetServByName()</a>
implementation of the standard Berkeley<p>
<a href="#AsyncGetServByPort">WSAAsyncGetServByPort()</a>
<b>gethostbyname()</b> function.<p>
<a href="#AsyncSelect">WSAAsyncSelect()</a>
Perform asynchronous version of <b>select()</b><p>
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
Cancel an outstanding instance of a <b>WSAAsyncGetXByY()</b> function.<p>
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
Cancel an outstanding "blocking" API call<p>
<a href="#Cleanup">WSACleanup()</a>
Sign off from the underlying Windows Sockets DLL.<p>
<a href="#GetLas#tError">WSAGetLastError()</a>
Obtain details of last Windows Sockets API error<p>
<a href="#IsBlocking">WSAIsBlocking()</a>
Determine if the underlying Windows Sockets DLL is already blocking an existing
call for this thread<p>
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
"Hook" the blocking method used by the underlying Windows Sockets
implementation<p>
<a href="#SetLastError">WSASetLastError()</a>
Set the error to be returned by a subsequent <b>WSAGetLastError()</b><p>
<a href="#Startup">WSAStartup()</a>
Initialize the underlying Windows Sockets DLL.<p>
<a href="#UnhookBlockingHook">WSAUnhookBlockingHook()</a>
Restore the original blocking function<p>


<hr><h3><a name="Windows_AsyncSelect">Asynchronous select() Mechanism</a></h3>

The 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
API allows an application to register an interest in one or many network
events.  This API is provided to supersede the need to do polled network I/O.
Any situation in which 
<a href="#Select">select()</a>
or non-blocking I/O routines (such as 
<a href="#Send">send()</a>
and 
<a href="#Recv">recv()</a>)
are either already used or are being considered is usually a candidate for the 
<a href="#AsyncSelect">WSAAsyncSelect()</a>
API.  When declaring interest in such condition(s), you supply a window handle
to be used for notification.  The corresponding window then receives
message-based notification of the conditions in which you declared an
interest.<p>

<a href="#AsyncSelect">WSAAsyncSelect()</a>
allows interest to be declared in the following conditions for a particular
socket:<p>
<ul>
<li> Socket readiness for reading
<li> Socket readiness for writing
<li> Out-of-band data ready for reading
<li> Socket readiness for accepting incoming connection
<li> Completion of non-blocking <a href="#Connect">connect()</a>
<li> Connection closure<p>
</ul>

<hr><h3><a name="Windows_AsyncSupport">Asynchronous Support Routines</a></h3>

The asynchronous "database" functions allow applications to request information
in an asynchronous manner.  Some network implementations and/or configurations
perform network based operations to resolve such requests.  The
<b>WSAAsyncGetXByY()</b> functions allow application developers to request
services which would otherwise block the operation of the whole Windows
environment if the standard Berkeley function were used.  The 
<a href="#CancelAsyncRequest">WSACancelAsyncRequest()</a>
function allows an application to cancel any outstanding asynchronous
request.<p>


<hr><h3><a name="Windows_HookingBlocking">Hooking Blocking Methods</a></h3>

As noted in 
<a href="#Overview_BlockingNonBlocking">Blocking/Non
blocking &amp; Data Volatility</a>, Windows Sockets implements blocking
operations in such a way that Windows message processing can continue, which
may result in the application which issued the call receiving a Windows
message.  In certain situations an application may want to influence or change
the way in which this pseudo-blocking process is implemented.  The 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
provides the ability to substitute a named routine which the Windows Sockets
implementation is to use when relinquishing the processor during a "blocking"
operation.<p>


<hr><h3><a name="Windows_ErrorHandling">Error Handling</a></h3>

For compatibility with thread-based environments, details of API errors are
obtained through the 
<a href="#GetLastError">WSAGetLastError()</a>
API.  Although the accepted "Berkeley-Style" mechanism for obtaining
socket-based network errors is via "errno", this mechanism cannot guarantee the
integrity of an error ID in a multi-threaded environment.  
<a href="#GetLastError">WSAGetLastError()</a>
allows you to retrieve an error code on a per thread basis.<p>

<a href="#GetLastError">WSAGetLastError()</a>
returns error codes which avoid conflict with standard Microsoft C error codes.
Certain error codes returned by certain Windows Sockets routines fall into the
standard range of error codes as defined by Microsoft C.  If you are NOT using
an application development environment which defines error codes consistent
with Microsoft C, you are advised to use the Windows Sockets error codes
prefixed by "WSA" to ensure accurate error code detection.<p>

Note that this specification defines a recommended set of error codes, and
lists the possible errors which may be returned as a result of each function.
It may be the case in some implementations that other Windows Sockets error
codes will be returned in addition to those listed, and applications should be
prepared to handle errors other than those enumerated under each API
description.  However a Windows Sockets implementation must not return any
value which is not enumerated in the table of legal Windows Sockets errors
given in 
<a href="#ErrorCodes">Error
Codes</a>.<p>

<hr><h3><a name="Windows_Intermediate">Accessing a Windows Sockets DLL from an Intermediate DLL</a></h3>

A Windows Sockets DLL may be accessed both directly from an application and
through an "intermediate" DLL.  An example of such an intermediate DLL would be
a virtual network API layer that supports generalized network functionality for
applications and uses Windows Sockets.  Such a DLL could be used by several
applications simultaneously, and the DLL must take special precautions with
respect to the <b>WSAStartup() </b>and<b> WSACleanup() </b>calls to ensure that
these routines are called in the context of each task that will make Windows
Sockets calls.  This is because the Windows Sockets DLL will need a call to
<b>WSAStartup() </b>for each task in order to set up task-specific data
structures, and a call to <b>WSACleanup() </b>to free any resources allocated
for the task.  <p>

There are (at least) two ways to accomplish this.  The simplest method is for
the intermediate DLL to have calls similiar to 
<a href="#Startup">WSAStartup()</a>
and
<a href="#Cleanup">WSACleanup()</a>
that applications call as appropriate.  The DLL would then call 
<a href="#Startup">WSAStartup()</a>
or
<a href="#Cleanup">WSACleanup()</a>
from within these routines.  Another mechanism is for the intermediate DLL
to build a table of task handles, which are obtained from the
<b>GetCurrentTask() </b>Windows API, and at each entry point into the
intermediate DLL check whether 
<a href="#Startup">WSAStartup()</a>
has been called for the current task, then call 
<a href="#Startup">WSAStartup()</a>
if necessary.<p>

If a DLL makes a blocking call and does not install its own blocking hook, then
the DLL author must be aware that control may be returned to the application
either by an application-installed blocking hook or by the default blocking
hook.  Thus, it is possible that the application will cancel the DLL's blocking
operation via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>.
If this occurs, the DLL's blocking operation will fail with the error code
<A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>, and the DLL must return control to the calling task as quickly as
possible, as the used has likely pressed a cancel or close button and the task
has requested control of the CPU.  It is recommended that DLLs which make
blocking calls install their own blocking hooks with 
<a href="#SetBlockingHook">WSASetBlockingHook()</a>
to prevent unforeseen interactions between the application and the
DLL.<i></i><p>
<i></i><p>
<i></i>Note that this is not necessary for DLLs in Windows NT because of its
different process and DLL structure.  Under Windows NT, the intermediate DLL
could simply call 
<a href="#Sta#rtup">WSAStartup()</a>
in its DLL initialization routine, which is called whenever a new process
which uses the DLL starts.<p>


<hr><h3><a name="Windows_InternalMessages">Internal use of Messages by Windows Sockets Implementations</a></h3>

In order to implement Windows Sockets purely as a DLL, it may be necessary for
the DLL to post messages internally for communication and timing.  This is
perfectly legal; however, a Windows Sockets DLL must not post messages to a
window handle opened by a client application except for those messages
requested by the application.  A Windows Sockets DLL that needs to use messages
for its own purposes must open a hidden window and post any necessary messages
to the handle for that window.<p>


<hr><h3><a name="Windows_PrivateAPIs">Private API Interfaces</a></h3>

The 
<a href="#Notes_DLLOrdinals">winsock.def</a>
file lists the ordinals defined for the Windows Sockets APIs.  In addition to
the ordinal values listed, all ordinals 999 and below are reserved for future
Windows Sockets use.  It may be convenient for a Windows Sockets implementation
to export additional, private interfaces from the Windows Sockets DLL.  This is
perfectly acceptable, as long as the ordinals for these exports are above 1000.
Note that any application that uses a particular Windows Sockets DLL's private
APIs will most likely not work on any other vendor's Windows Sockets
implementation.  Only the APIs defined in this document are guaranteed to be
present in every Windows Sockets implementation.<p>

If an application uses private interfaces of a particular vendor's Windows
Sockets DLL, it is recommended that the DLL not be statically linked with the
application but rather dynamically loaded with the Windows routines
<b>LoadLibrary()</b> and <b>GetProcAddress().</b>  This allows the application
to give an informative error message if it is run on a system with a Windows
Sockets DLL that does not support the same set of extended functionality.

<hr><h1><a name="SocketLibraryReference">Socket Library Reference</a></h1>

<hr><h2><a name="Ref_SocketRoutines">Socket Routines</a></h2>

This chapter presents the socket library routines in alphabetical order, and
describes each routine in detail.  <p>

In each routine it is indicated that the header file 
<a href="#WinsockH">winsock.h</a>
must be included.  
<a href="#HeaderFiles">Header
Files</a> lists the Berkeley-compatible header files which are supported.
These are provided for compatibility purposes only, and each of them will
simply include 
<a href="#WinsockH">winsock.h</a>.
The Windows header file <b>windows.h</b> is also needed, but <b>winsock.h</b>
will include it if necessary.<p>

<hr><h3>
<a name="Accept">accept()</a></h3>
<h4>Description</h4>
Accept a connection on a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>SOCKET PASCAL FAR accept ( SOCKET </b><i>s</i><b>, struct sockaddr FAR *
</b><i>addr<b>,</b></i><b> int FAR * </b><i>addrlen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying a socket which is listening for connections after
a <b>listen</b>().
<dt><i>addr</i>
<dd>An optional pointer to a buffer which receives the address of the
connecting entity, as known to the communications layer.  The exact format of
the <i>addr</i> argument is determined by the address family established when
the socket was created.
<dt><i>addrlen</i>
<dd>A optional pointer to an integer which contains the length of the address
<i>addr</i>.</dl>
<h4>Remarks</h4>
This routine extracts the first connection on the queue of
pending connections on <i>s</i>, creates a new socket with the same properties
as <i>s</i> and returns a handle to the new socket.  If no pending connections
are present on the queue, and the socket is not marked as non-blocking,
<b>accept()</b> blocks the caller until a connection is present.  If the socket
is marked non-blocking and no pending connections are present on the queue,
<b>accept()</b> returns an error as described below.  The accepted socket may
not be used to accept more connections.  The original socket remains open.
<p>
The argument <i>addr</i> is a result parameter that is filled in with the
address of the connecting entity, as known to the communications layer.  The
exact format of the <i>addr</i> parameter is determined by the address family
in which the communication is occurring.  The <i>addrlen</i> is a value-result
parameter; it should initially contain the amount of space pointed to by
<i>addr</i>; on return it will contain the actual length (in bytes) of the
address returned.  This call is used with connection-based socket types such as
SOCK_STREAM.  If <i>addr</i> and/or <i>addrlen</i> are equal to NULL, then no
information about the remote address of the accepted socket is returned.<p>


<h4>Return Value</h4>
If no error occurs, <b>accept</b>() returns a value of type
SOCKET which is a descriptor for the accepted packet.  Otherwise, a value of
INVALID_SOCKET is returned, and a specific error code may be retrieved by
calling 
<a href="#GetLastError">WSAGetLastError()</a>.<p>

The integer referred to by <i>addrlen</i> initially contains the amount of
space pointed to by <i>addr</i>.  On return it will contain the actual length
in bytes of the address returned.

<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAEFAULT">WSAEFAULT</A>
<dd>The <i>addrlen</i> argument is too small (less than the sizeof a struct
sockaddr).
<dt><A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>
<dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets call is in progress.
<dt><A HREF="err_lst1.htm#WSAEINVAL">WSAEINVAL</A>
<dd>
<a href="#Listen">listen()</a>
was not invoked prior to <b>accept()</b>.
<dt><A HREF="err_lst1.htm#WSAEMFILE">WSAEMFILE</A>
<dd>The queue is empty upon entry to <b>accept()</b> and there are no
descriptors available.
<dt><A HREF="err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
<dd>No buffer space is available.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.
<dt><A HREF="err_lst1.htm#WSAEOPNOTSUPP">WSAEOPNOTSUPP</A>
<dd>The referenced socket is not a type that supports connection-oriented
service.
<dt><A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>
<dd>The socket is marked as non-blocking and no connections are present to be
accepted.
<dt></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Connect">connect()</a><b>,
</b>
<a href="#Listen">listen()</a><b>,
</b>
<a href="#Select">select()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

<hr><h3>
<a name="Bind">bind()</a></h3>
<h4>Description</h4>
Associate a local address with a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int PASCAL FAR bind ( SOCKET </b><i>s<b>,</b></i><b> const struct sockaddr
FAR * </b><i>name</i><b>, int </b><i>namelen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying an unbound socket.
<dt><i>name</i>
<dd>The address to assign to the socket.  The sockaddr structure is defined as
follows:</dl>

<pre>

	struct sockaddr {
		u_short	sa_family;
		char	sa_data[14];
	};
</pre>
<dl>
<dt><i>namelen</i>
<dd>The length of the <i>name</i>.</dl>
<h4>Remarks</h4>
This routine is used on an unconnected datagram or stream
socket, before subsequent 
<a href="#Connect">connect()</a>s
or 
<a href="#Listen">listen()</a>s.
When a socket is created with 
<a href="#Socket">socket()</a>,
it exists in a name space (address family), but it has no name assigned.
<b>bind</b>() establishes the local association (host address/port number) of
the socket by assigning a local name to an unnamed socket.<p>

In the Internet address family, a name consists of several components.  For
SOCK_DGRAM and SOCK_STREAM, the name consists of three parts: a host address,
the protocol number (set implicitly to UDP or TCP, respectively), and a port
number which identifies the application.  If an application does not care what
address is assigned to it, it may specify an Internet address equal to
INADDR_ANY, a port equal to 0, or both.  If the Internet address is equal to
INADDR_ANY, any appropriate network interface will be used; this simplifies
application programming in the presence of multi-homed hosts.  If the port is
specified as 0, the Windows Sockets implementation will assign a unique port to
the application with a value between 1024 and 5000.  The application may use 
<a href="#GetSockName">getsockname()</a>
after <b>bind()</b> to learn the address that has been assigned to it, but note
that <b>getsockname()</b> will not necessarily fill in the Internet address
until the socket is connected, since several Internet addresses may be valid if
the host is multi-homed.<p>

If an application desires to bind to an arbitrary port outside of the range
1024 to 5000, such as the case of rsh which must bind to any reserved port,
code similar to the following may be used:


<pre>
    SOCKADDR_IN sin;
    SOCKET s;
    u_short alport = IPPORT_RESERVED;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    for (;;) {
        sin.sin_port = htons(alport);
        if (bind(s, (LPSOCKADDR)&amp;sin, sizeof (sin)) == 0) {
            /* it worked */
        }
        if ( GetLastError() != <A HREF="err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>) {
            /* fail */
        }
        alport--;
        if (alport == IPPORT_RESERVED/2 ) {
            /* fail--all unassigned reserved ports are */
            /* in use. */
        }
    }
</pre>

<h4>Return Value</h4>
If no error occurs, <b>bind()</b> returns 0.  Otherwise, it
returns SOCKET_ERROR, and a specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a>.

<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a> 
<dd>The specified address is already in use.  (See the SO_REUSEADDR socket
option under 
<a href="#SetSockOpt">setsockopt()</a>.)
<dt><A HREF="err_lst1.htm#WSAEFAULT">WSAEFAULT</A>
<dd>The <i>namelen</i> argument is too small (less than the size of a struct
sockaddr).
<dt><A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>
<dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets call is in progress.
<dt><A HREF="err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
<dd>The specified address family is not supported by 
<dt>this protocol.
<dt><A HREF="err_lst1.htm#WSAEINVAL">WSAEINVAL</A>
<dd>The socket is already bound to an address.
<dt><A HREF="err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
<dd>Not enough buffers available, too many connections.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.</dl>
<b>See Also</b>	
<a href="#Connect">connect()</a><b>,</b>
<a href="#Listen">listen()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>,</b>
<a href="#SetSockOpt">setsockopt()</a><b>,</b>
<a href="#Socket">socket()</a><b>,</b>
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a><b>.</b><p>

<hr><h3>
<a name="CloseSocket">closesocket()</a></h3>
<h4>Description</h4>
Close a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int FAR PASCAL closesocket ( SOCKET </b><i>s</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying a socket.</dl>
<h4>Remarks</h4>
This function closes a socket.  More precisely, it releases the
socket descriptor <i>s</i>, so that further references to <i>s</i> will fail
with the error <A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>.  If this is the last reference to the underlying
socket, the associated naming information and queued data are discarded.<p>

The semantics of <b>closesocket</b>() are affected by the socket options
SO_LINGER and SO_DONTLINGER as follows:

<pre>
<b>Option		Interval	Type of close		Wait for close?</b>
---------------	---------------	-----------------------	----------------
SO_DONTLINGER	Don't care	Graceful		No

SO_LINGER	Zero		Hard			No

SO_LINGER	Non-zero	Graceful		Yes
</pre><p>
If SO_LINGER is set (i.e. the <i>l_onoff</i> field of the linger structure is
non-zero; see 
<a href="#Prog_SocketOptions">Socket
Options</a>, 
<a href="#GetSockOpt">getsockopt()</a>
and 
<a href="#SetSockOpt">setsockopt()</a>)
with a zero timeout interval (<i>l_linger</i> is zero), <b>closesocket()</b> is
not blocked even if queued data has not yet been sent or acknowledged.  This is
called a "hard" close, because the socket is closed immediately, and any unsent
data is lost.  Any 
<a href="#Recv">recv()</a>
call on the remote side of the circuit can fail with <A HREF="err_lst1.htm#WSAECONNRESET">WSAECONNRESET</a>.<p>

If SO_LINGER is set with a non-zero timeout interval, the <b>closesocket()</b>
call blocks until the remaining data has been sent or until the timeout
expires.  This is called a graceful disconnect.  Note that if the socket is set
to non-blocking and SO_LINGER is set to a non-zero timeout, the call to
<b>closesocket() </b>will fail with an error of <A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>.

If SO_DONTLINGER is set on a stream socket (i.e. the <i>l_onoff</i> field of
the linger structure is zero; see 
<a href="#Prog_SocketOptions">Socket
Options</a>, 
<a href="#GetSockOpt">getsockopt()</a>
and 
<a href="#SetSockOpt">setsockopt()</a>),
the <b>closesocket()</b> call will return immediately.  However, any data
queued for transmission will be sent if possible before the underlying socket
is closed.  This is also called a graceful disconnect.  Note that in this case
the Windows Sockets implementation may not release the socket and other
resources for an arbitrary period, which may affect applications which expect
to use all available sockets.
<p>

<h4>Return Value</h4>
If no error occurs, <b>closesocket()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>
<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets call is in progress.
<dt><A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>
<dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a><b>.</b>
<dt><A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>
<dd>The socket is marked as nonblocking and SO_LINGER is set to a nonzero
timeout value.
<dt></dl><p>
<h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#IOCTLSocket">ioctlsocket()</a><b>,
</b>
<a href="#SetSockOpt">setsockopt()</a><b>,
</b>
<a href="#AsyncSelect">WSAAsyncSelect()</a><b>.</b><p>

<hr><h3>
<a name="Connect">connect()</a></h3>
<h4>Description</h4>
Establish a connection to a peer.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int PASCAL FAR connect ( SOCKET </b><i>s</i><b>, const struct sockaddr FAR
* </b><i>name</i><b>, int </b><i>namelen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying an unconnected socket.
<dt><i>name</i>
<dd>The name of the peer to which the socket is to be connected.
<dt><i>namelen</i>
<dd>The length of the <i>name</i>.</dl>
<h4>Remarks</h4>
This function is used to create a connection to the specified
foreign association.  The parameter <i>s</i> specifies an unconnected datagram
or stream socket  If the socket is unbound, unique values are assigned to the
local association by the system, and the socket is marked as bound.  Note that
if the address field of the <i>name</i> structure is all zeroes,
<b>connect()</b> will return the error <A HREF="err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>.
<p>
For stream sockets (type SOCK_STREAM), an active connection is initiated to the
foreign host using <i>name</i> (an address in the name space of the socket).
When the socket call completes successfully, the socket is ready to
send/receive data.  <p>

For a datagram socket (type SOCK_DGRAM), a default destination is set, which
will be used on subsequent 
<a href="#Send">send()</a>
and 
<a href="#Recv">recv()</a>
calls.<p>

On a non-blocking socket, if the return value is SOCKET_ERROR an application
should call 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>
If this indicates an error code of <A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A>, then your application can
either:<p>

<OL>
<LI> Use <b>select()</b> to determine the completion of the connection request
by checking if the socket is writeable, or

<LI> If your application is using the message-based
<a href="#AsyncSelect">WSAAsyncSelect()</a> to indicate interest in connection
events, then your application will receive an FD_CONNECT message when the
connect operation is complete.
</OL>

<h4>Return Value</h4>
If no error occurs, <b>connect()</b> returns 0.  Otherwise,
it returns SOCKET_ERROR, and a specific error code may be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b><p>

On a blocking socket, the return value indicates success or failure of the
connection attempt.<p>

<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAEADDRINUSE">WSAEADDRINUSE</a>
<dd>The specified address is already in use.
<dt><A HREF="err_lst1.htm#WSAEINTR">WSAEINTR</A>
<dd>The (blocking) call was canceled via 
<a href="#CancelBlockingCall">WSACancelBlockingCall()</a>
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets call is in progress.
<dt><A HREF="err_lst1.htm#WSAEADDRNOTAVAIL">WSAEADDRNOTAVAIL</a>
<dd>The specified address is not available from the local machine.
<dt><A HREF="err_lst1.htm#WSAEAFNOSUPPORT">WSAEAFNOSUPPORT</a>
<dd>Addresses in the specified family cannot be used with this socket.
<dt><A HREF="err_lst1.htm#WSAECONNREFUSED">WSAECONNREFUSED</a>
<dd>The attempt to connect was forcefully rejected.
<dt><A HREF="err_lst1.htm#WSAEDESTADDREQ">WSAEDESTADDREQ</A>
<dd>A destination address is required.
<dt><A HREF="err_lst1.htm#WSAEFAULT">WSAEFAULT</A>
<dd>The <i>namelen</i> argument is incorrect.
<dt><A HREF="err_lst1.htm#WSAEINVAL">WSAEINVAL</A>
<dd>The socket is not already bound to an address.
<dt><A HREF="err_lst1.htm#WSAEISCONN">WSAEISCONN</a>
<dd>The socket is already connected.
<dt><A HREF="err_lst1.htm#WSAEMFILE">WSAEMFILE</A>
<dd>No more file descriptors are available.
<dt><A HREF="err_lst1.htm#WSAENETUNREACH">WSAENETUNREACH</a>
<dd>The network can't be reached from this host at this time.
<dt><A HREF="err_lst1.htm#WSAENOBUFS">WSAENOBUFS</a>
<dd>No buffer space is available.  The socket cannot be connected.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.
<dt><A HREF="err_lst1.htm#WSAETIMEDOUT">WSAETIMEDOUT</a>
<dd>Attempt to connect timed out without establishing a connection
<dt><A HREF="err_lst1.htm#WSAEWOULDBLOCK">WSAEWOULDBLOCK</A> 
<dd>The socket is marked as non-blocking and the connection cannot be completed
immediately.  It is possible to 
<a href="#Select">select()</a>
the socket while it is connecting by <b>select()</b>ing it for writing.</dl>
<h4>See Also</h4>
<a href="#Accept">accept()</a><b>,
</b>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>,
</b>
<a href="#Select">socket()</a>,
and 
<a href="#AsyncSelect">WSAAsyncSelect</a><b>.</b><p>

<hr><h3>
<a name="GetPeerName">getpeername()</a></h3>
<h4>Description</h4>
Get the address of the peer to which a socket is
connected.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int PASCAL FAR getpeername(SOCKET </b><i>s</i><b>, struct sockaddr FAR *
</b><i>name</i><b>, int FAR * </b><i>namelen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying a connected socket.
<dt><i>name</i>
<dd>The structure which is to receive the name of the peer.
<dt><i>namelen</i>
<dd>A pointer to the size of the <i>name</i> structure.</dl>
<h4>Remarks</h4>
<b>getpeername()</b> retrieves the name of the peer connected to
the socket <i>s</i> and stores it in the struct sockaddr identified by
<i>name</i>.  It is used on a connected datagram or stream socket.

On return, the <i>namelen</i> argument contains the actual size of the name
returned in bytes.
<p>

<h4>Return Value</h4>
If no error occurs, <b>getpeername()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAEFAULT">WSAEFAULT</A>
<dd>The namelen argument is not large enough.
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets call is in progress.
<dt><A HREF="err_lst1.htm#WSAENOTCONN">WSAENOTCONN</a>
<dd>The socket is not connected.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.</dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#GetSockName">getsockname()</a><b>.</b><p>

<hr><h3>
<a name="GetSockName">getsockname()</a></h3>
<h4>Description</h4>
Get the local name for a socket.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int PASCAL FAR getsockname(SOCKET </b>s<b>, struct sockaddr FAR *
</b><i>name</i><b>, int FAR * </b><i>namelen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying a bound socket.
<dt><i>name</i>
<dd>Receives the address (name) of the socket.
<dt><i>namelen</i>
<dd>The size of the <i>name</i> buffer.</dl>
<h4>Remarks</h4>
<b>getsockname()</b> retrieves the current name for the
specified socket descriptor in <i>name</i>.  It is used on a bound and/or
connected socket specified by the <i>s</i> parameter.  The local association is
returned.  This call is especially useful when a 
<a href="#Connect">connect()</a>
call has been made without doing a 
<a href="#Bind">bind()</a>
first; this call provides the only means by which you can determine the local
association which has been set by the system.<p>

	On return, the <i>namelen</i> argument contains the actual size of the name
returned in bytes.
<p>
If a socket was bound to INADDR_ANY, indicating that any of the host's IP
addresses should be used for the socket, <b>getsockname()</b> will not
necessarily return information about the host IP address, unless the socket has
been connected with 
<a href="#Connect">connect()</a>
or 
<a href="#Accept">accept()</a><b>.</b>
A Windows Sockets application must not assume that the IP address will be
changed from INADDR_ANY unless the socket is connected.  This is because for a
multi-homed host the IP address that will be used for the socket is unknown
unless the socket is connected.
<p>

<h4>Return Value</h4>
If no error occurs, <b>getsockname()</b> returns 0.
Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may
be retrieved by calling 
<a href="#GetLastError">WSAGetLastError()</a><b>.</b>

<h4>Error Codes</h4>
<dl>
<dt><A HREF="err_lst1.htm#WSANOTINITIALISED">WSAENOTINITIALISED</A>
<dd>A successful 
<a href="#Startup">WSAStartup()</a>
must occur before using this API.
<dt><A HREF="err_lst1.htm#WSAENETDOWN">WSAENETDOWN</a>
<dd>The Windows Sockets implementation has detected that the network subsystem
has failed.
<dt><A HREF="err_lst1.htm#WSAEFAULT">WSAEFAULT</A>
<dd>The <i>namelen</i> argument is not large enough.
<dt><A HREF="err_lst1.htm#WSAEINPROGRESS">WSAEINPROGRESS</a>
<dd>A blocking Windows Sockets operation is in progress.
<dt><A HREF="err_lst1.htm#WSAENOTSOCK">WSAENOTSOCK</a>
<dd>The descriptor is not a socket.
<dt><A HREF="err_lst1.htm#WSAEINVAL">WSAEINVAL</A>
<dd>The socket has not been bound to an address with 
<a href="#Bind">bind()</a><b>.</b></dl>
<h4>See Also</h4>
<a href="#Bind">bind()</a><b>,
</b>
<a href="#Socket">socket()</a><b>,
</b>
<a href="#GetPeerName">getpeername()</a><b>.</b><p>

<hr><h3>
<a name="GetSockOpt">getsockopt()</a></h3>
<h4>Description</h4>
Retrieve a socket option.<p>

<code> 	#include &lt;winsock.h&gt;</code><p>

<b>int PASCAL FAR getsockopt ( SOCKET </b><i>s</i><b>, int
</b><i>level</i><b>, int </b><i>optname</i><b>, char FAR *
</b><i>optval</i><b>, int FAR * </b><i>optlen</i><b>);</b>
<dl>
<dt><i>s</i>
<dd>A descriptor identifying a socket.
<dt><i>level</i>
<dd>The level at which the option is defined; the only supported <i>levels</i>
are SOL_SOCKET and IPPROTO_TCP.
<dt><i>optname</i>
<dd>The socket option for which the value is to be retrieved.
<dt><i>optval</i>
<dd>A pointer to the buffer in which the value for the requested option is to
be returned.
<dt><i>optlen</i>
<dd>A pointer to the size of the <i>optval</i> buffer.</dl>
<h4>Remarks</h4>
<b>getsockopt()</b> retrieves the current value for a socket
option associated with a socket of any type, in any state, and stores the
result in <i>optval</i>.  Options may exist at multiple protocol levels, but
they are always present at the uppermost ``socket'' level.  Options affect
socket operations, such as whether an operation blocks or not, the routing of
packets, out-of-band data transfer, etc.

The value associated  with the selected option is returned in the buffer
<i>optval</i>.  The integer pointed to by  <i>optlen</i> should originally
contain the size of this buffer; on return, it will be set to the size of the
value returned.  For SO_LINGER, this will be the size of  a struct linger; for
all other options it will be the size of an integer.<p>

If the option was never set with 
<a href="#SetSockOpt">setsockopt()</a><b>,</b>
then <b>getsockopt()</b> returns the default value for the option.<p>

The following options are supported for <b>getsockopt()</b>.  The <b>Type</b>
identifies the type of data addressed by <i>optval</i>.  The TCP_NODELAY option
uses level IPPROTO_TCP, all other options use level SOL_SOCKET.

<pre>
<b><u>Value		Type		Meaning</u></b>
---------------	---------------	----------